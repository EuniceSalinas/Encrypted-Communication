/*
 MAJOR 2
 MAJOR GROUP 21
 COURSE: CSCE 3600 001
 DATE: May 03 2018
 TEAM MEMBERS:  1. Eunice Salinas
                2. Dheepthi Somangili Babulal
                3. Megdelawit Woldeselassie
 
 DESCRIPTION:   This is the client side code for major 2. It prompts the user for 2
                integers and sends the integer to the server. It then recieves
                the private or public key generated by the server(using RSA
                algorithm).It then prompts the user for input text and encrypts it
                using the private key and sends it to the other connected client and
                sends encrypted cipher and if it recieves the public key then it
                performs decryption of the encrypted cipher it recieved from the other
                client.
 
 */



#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <netdb.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <arpa/inet.h>
#include <fcntl.h>
#include <sys/time.h>




int main(int argc, char *argv[])
{
    int sockfd = 0, clifd = 0, port, cli_port, listenfd = 0, cli_size, second_client = 0;
    char buffer[1025];
    int len;
    
    char msg[1025];
    char msg2[1025];
    char textMsg[1025];
    int enc[1025];
    char dec[1025];
    unsigned int c,m;
    char sendbuf[1025];
    char recvbuf[1025];
    char *ip_addr;
    int on,i,j,k;
    struct sockaddr_in serv_addr, cli_as_serv_addr, cli_addr, remote_addr;
    struct  hostent *server;
    char letter;

    //usage error
    if(argc != 5)
    {
        printf("usage: ./a.out hostname svrport ipAddress cliport ");
        exit(EXIT_FAILURE);
    }
    
    port = atoi(argv[2]);   // svr port
    cli_port = atoi(argv[4]); //cli port no
    ip_addr = argv[3];      // ip address of the other client
    
    memset(buffer, '0', sizeof(buffer));
    memset(sendbuf, '0', sizeof(sendbuf));
    memset(recvbuf, '0', sizeof(recvbuf));
    
    //set socket for client - client
    if((clifd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    {
        printf("socket error\n");
        exit(EXIT_FAILURE);
    }
    
    //set socket for server
    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    {
        printf("socket error\n");
        exit(EXIT_FAILURE);
    }
    
    //get host name in command line
    if((server = gethostbyname(argv[1])) == NULL)
    {
        perror("Host Error");
        exit(EXIT_FAILURE);
    }
    
    //for serv_addr
    bzero((char *) &serv_addr, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    bcopy((char *)server->h_addr, (char *)&serv_addr.sin_addr.s_addr, server->h_length);
    serv_addr.sin_port = htons(port);
    
    //connect to server
    if (connect(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr) ) < 0)
    {
        printf("connect error\n");
        exit(EXIT_FAILURE);
    }
    
    fd_set fds;//fd set
    int nread, nready, temp, temp2, n, d, e;//used as temp variables to check for errors and RSA calculations
    int zero = 0, sent_flag = 0, rec_flag = 0;//flags 
    int maxfd = sockfd+1;//maxfd for select

    while(1){
	//set up fd set
        FD_ZERO(&fds);
        FD_SET(sockfd, &fds);
        FD_SET(0, &fds);
        
	//wait for input
        nready = select(maxfd, &fds, (fd_set *) 0, (fd_set *) 0, (struct timeval *) 0);
        
	//input from server
        if(FD_ISSET(sockfd, &fds))
        {
	    //read input
            nread = recv(sockfd, buffer, sizeof(buffer), 0);
            if(nread < 1)//error case
            {
                close(sockfd);
                exit(0);
            }

            if(strcmp(buffer, "KEY ") == 0)   // client recieves the public key
            {
                recv(sockfd, &d, sizeof(d), 0);
                recv(sockfd, &n, sizeof(n), 0);
                printf("SERVER MESSAGE: KEY %d %d\n", d, n);
                printf("PUBLIC KEY : d = %d, n = %d\n", d, n);
                sleep(2);
                
                bzero((char *) &remote_addr, sizeof(remote_addr));
                remote_addr.sin_family = AF_INET;
                remote_addr.sin_port = htons(cli_port);
                remote_addr.sin_addr.s_addr = inet_addr(ip_addr);
                if(connect(clifd, (struct sockaddr *)&remote_addr, sizeof(remote_addr)) < 0)  // setting up another connection woth other client
                {
                    printf("connect error\n");
                    exit(EXIT_FAILURE);
                }
               	
		printf("Waiting on other Client Message. Please wait....\n");
                //decryption stuff here
                i=0;
                
                nread = recv(clifd, msg2, sizeof(msg2), 0);   // reading the length of the message from other client
                if(nread < 1)
                {
                    close(clifd);
                    exit(0);
                }
                len = atoi(msg2);   // length of the text message
                bzero(msg2,sizeof(msg2));

		/* decryption starts here */
                
                printf("Recieved encrypted cipher: ");
                i=0;j=0;
                while(i<len)
                {
                    read(clifd, recvbuf, sizeof(recvbuf));   // reading cipher one by one
                    enc[i] = atoi(recvbuf);
                    bzero(recvbuf,sizeof(recvbuf));
                    m = enc[i];
		    printf(" %u", m);
                    for(j=0;j<(d-1);j++)    // decryption of the recieved cipher one by one
                    {
                        m = (m*enc[i])%n;
                    }
                    dec[i]= m;
                    i++;
                }
                
                
                printf("\nDecrypted message: ");
                for(i =0;i<len;i++)                 // printing the decrypted message
                {
                    printf("%c",dec[i]);
                }
                
		printf("\n");
                printf("Other client Disconnected....\n");
                close(clifd); //disconnect other client
		wait(2);//wait for other client to set up

		//if already sent and recived terminate otherwise ask for prompt
		if(sent_flag == 0)
		{
			rec_flag = 1;
			temp2 = 9999;
			write(sockfd, &temp2, sizeof(temp2));	
		}else
		{
			printf("Client Messages Sent and Received. Terminating...\n");
			write(sockfd, &zero, sizeof(zero));
		}
            }
            else if(strcmp(buffer, "PRK ") == 0)  //PRIVATE KEY
            {
                recv(sockfd, &e, sizeof(e), 0);     // recieving the private key
                recv(sockfd, &n, sizeof(n), 0);
                printf("PRIVATE KEY: e = %d n = %d\n", e, n);
                
                //set up new network socket for cli - cli connection
                if((listenfd = socket(AF_INET, SOCK_STREAM, 0)) == -1)
                {
                    printf("socket error\n");
                    exit(EXIT_FAILURE);
                }
                
                memset(&cli_as_serv_addr, '0', sizeof(&cli_as_serv_addr));
                memset(msg, '0', sizeof(msg));
                
                bzero((char *) &cli_as_serv_addr, sizeof(cli_as_serv_addr));
                cli_as_serv_addr.sin_family = AF_INET;
                cli_as_serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
                cli_as_serv_addr.sin_port = htons(cli_port);
                
                on = 1;
                setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));
                
                if(bind(listenfd, (struct sockaddr*)&cli_as_serv_addr, sizeof(cli_as_serv_addr))== -1)
                {
                    perror("Bind Failed");
                    exit(EXIT_FAILURE);
                }
                
                if(listen(listenfd, 100) == -1)
                {
                    perror("Listen Failed");
                    exit(EXIT_FAILURE);
                }
                if((second_client = accept(listenfd, (struct sockaddr*)&cli_addr, &cli_size)) == -1)
                {
                    perror("Accept failed");
                    exit(EXIT_FAILURE);
                }
                
                printf("Connection Accepted\n");  // connection has been established
                printf("Handler assigned \n");
                
                //encryption stuff here
                printf("Enter plain text message: ");   // getting text for encryption
                i=0;
                letter=getchar();       // getting character by character of the message to be encrypted
                do{
                    textMsg[i]=letter;
                    i++;
                }while((letter=getchar()) != '\n'&& i<1025 );
                
                textMsg[i] = '\n'; /* null-terminate the string */
                i=0;
                printf("Encrypted message: ");
                len = strlen(textMsg);      // finding the length of the message to be encrypted
                i =0;
                while(i<len)   // ENCRYPTION STARTS
                {
                    m = textMsg[i];
                    c = textMsg[i];
                    for(j=0;j<(e-1);j++)
                    {
                        c = (c*m)%n;
                        enc[i] = c;
                    }
                    printf("%d ",enc[i]);
                    i++;
                }
                printf("\n");       //ENCRYPTION ENDS
                
                gcvt(len, 6, sendbuf);
                
                write(second_client,sendbuf,sizeof(sendbuf));   // sending the length of the input message
                bzero(sendbuf,sizeof(sendbuf));
                
                i=0;
                while(i<len)                    // sending the encrypted cipher one by one
                {
                    gcvt(enc[i], 6, sendbuf);
                    write(second_client,sendbuf,sizeof(sendbuf));
                    bzero(sendbuf,sizeof(sendbuf));
                    i++;
                }
                //encryption ends
                
                
                close(second_client);//disconnect from second client

		//if recived and sent then terminate, otherwise wait for input
		if(rec_flag == 0)
		{
			sent_flag = 1;
                	printf("Other Client Disconnected\n(Message Sending Disabled)\n");
		}else
		{
			printf("Client Messages Sent and Recived. Terminating....\n");
			write(sockfd, &zero, sizeof(zero));	
		}
                
            }else if(strcmp(buffer, "0") == 0){

		//if recived a 0 from server disconnect from server	
		recv(sockfd, buffer, sizeof(buffer), 0);
		printf("%s\n", buffer);
		close(second_client);	
		close(clifd);
		exit(0);

            }else if(strcmp(buffer, "INVALID") == 0){

		//if numbers invalid then ask for prompt
		printf("%s\n", buffer);
		temp2 = 9999;
		write(sockfd, &temp2, sizeof(temp2));

	    }else{
		//print to screen
                write(1, buffer, nread);
            }
        }
        
	//if input and messages are disabled
	if((FD_ISSET(0, &fds)) && (sent_flag == 1))
	{
		scanf("%d %d", &temp, &temp2);
		if(temp == 0) //if the input was 0 0
		{
			write(sockfd, &zero, sizeof(zero));//send zero to the server
		}else
		{
			printf("Message already sent. Unable to send additional data.\n");
		}
		
	}else if(FD_ISSET(0, &fds))
        {
	    //scan 2 intigers and send them to server
            scanf("%d %d", &temp, &temp2);
            write(sockfd, &temp, sizeof(temp));
            if(temp != 0)
            {
                write(sockfd, &temp2, sizeof(temp2));
            }
        }
    }
    
    
    return 0;
}


